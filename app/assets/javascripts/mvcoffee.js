// Generated by CoffeeScript 1.8.0

/*

MVCoffee

Copyright 2014, Kirk Bowers
MIT License

Version 1.0.0
 */

(function() {
  var MVCoffee,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if (typeof exports !== "undefined" && exports !== null) {
    MVCoffee = exports;
  } else {
    this.MVCoffee || (this.MVCoffee = {});
    MVCoffee = this.MVCoffee;
  }

  if (!Array.isArray) {
    Array.isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    };
  }

  this.link_to = function(label, link, opts) {
    var result;
    if (opts == null) {
      opts = {};
    }
    result = '<a href="' + link + '"';
    if (opts.id != null) {
      result += ' id="' + opts.id + '"';
    }
    if (opts["class"] != null) {
      result += ' class="' + opts["class"] + '"';
    }
    if (opts.method != null) {
      result += ' rel="nofollow" data-method="' + opts.method + '"';
    }
    result += '>' + label + '</a>';
    return result;
  };

  MVCoffee.Pluralizer = (function() {
    function Pluralizer() {}

    Pluralizer.irregulars = {
      man: "men",
      woman: "women",
      child: "children",
      person: "people",
      mouse: "mice",
      goose: "geese",
      datum: "data",
      alumnus: "alumni",
      cactus: "cacti",
      hippopotamus: "hippopotami"
    };

    Pluralizer.addIrregulars = function(words) {
      var plur, sing, _results;
      _results = [];
      for (sing in words) {
        plur = words[sing];
        _results.push(this.irregulars[sing] = plur);
      }
      return _results;
    };

    Pluralizer.addIrregular = Pluralizer.addIrregulars;

    Pluralizer.pluralize = function(word) {
      var lastIndex, lastLetter, lastTwo, lastWord, len, result, words;
      words = word.split("_");
      lastIndex = words.length - 1;
      lastWord = words[lastIndex];
      result = this.irregulars[lastWord];
      if (result) {
        words[lastIndex] = result;
        return words.join("_");
      }
      len = lastWord.length;
      lastLetter = lastWord[len - 1];
      lastTwo = lastWord.slice(len - 2, +(len - 1) + 1 || 9e9);
      if (lastLetter === "s" || lastLetter === "z") {
        lastWord += "es";
      } else if (lastTwo === "ch" || lastTwo === "sh") {
        lastWord += "es";
      } else if (lastLetter === "y") {
        lastWord = lastWord.substring(0, len - 1) + "ies";
      } else {
        lastWord += "s";
      }
      words[lastIndex] = lastWord;
      return words.join("_");
    };

    return Pluralizer;

  })();

  MVCoffee.Runtime = (function() {
    function Runtime() {
      this.processServerData = __bind(this.processServerData, this);
      this.getErrors = __bind(this.getErrors, this);
      this.getSession = __bind(this.getSession, this);
      this.setSession = __bind(this.setSession, this);
      this.getFlash = __bind(this.getFlash, this);
      this.setFlash = __bind(this.setFlash, this);
      this.controllers = {};
      this.modelStore = new MVCoffee.ModelStore;
      this.active = [];
      this._flash = {};
      this._oldFlash = {};
      this.session = {};
      this.dataId = "mvcoffee_json";
      this.onfocusId = null;
    }

    Runtime.prototype.register_controllers = function(contrs) {
      var contr, id, _results;
      _results = [];
      for (id in contrs) {
        contr = contrs[id];
        _results.push(this._addController(new contr(id, this), id));
      }
      return _results;
    };

    Runtime.prototype._addController = function(contr, id) {
      if (id != null) {
        return this.controllers[id] = contr;
      } else {
        return this.controllers[contr.selector] = contr;
      }
    };

    Runtime.prototype.register_models = function(models) {
      return this.modelStore.register_models(models);
    };

    Runtime.prototype.broadcast = function() {
      var args, controller, i, message, messages, sent, _i, _len, _ref, _results;
      messages = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!Array.isArray(messages)) {
        messages = [messages];
      }
      _ref = this.active;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        controller = _ref[_i];
        sent = false;
        i = 0;
        _results.push((function() {
          var _results1;
          _results1 = [];
          while (!sent && i < messages.length) {
            message = messages[i];
            if (message && (controller[message] != null) && typeof controller[message] === 'function') {
              sent = true;
              controller[message].apply(controller, args);
            }
            _results1.push(i++);
          }
          return _results1;
        })());
      }
      return _results;
    };

    Runtime.prototype.setFlash = function(opts) {
      var key, opt, _results;
      _results = [];
      for (key in opts) {
        opt = opts[key];
        _results.push(this._flash[key] = opt);
      }
      return _results;
    };

    Runtime.prototype.getFlash = function(key) {
      var _ref;
      return (_ref = this._flash[key]) != null ? _ref : this._oldFlash[key];
    };

    Runtime.prototype.setSession = function(opts) {
      var key, opt, _results;
      _results = [];
      for (key in opts) {
        opt = opts[key];
        _results.push(this.session[key] = opt);
      }
      return _results;
    };

    Runtime.prototype.getSession = function(key) {
      return this.session[key];
    };

    Runtime.prototype.getErrors = function() {
      return this.errors;
    };

    Runtime.prototype.processServerData = function(data, callback_message) {
      var error_callback_message, key, value, _ref;
      if (callback_message == null) {
        callback_message = "";
      }
      if (data) {
        console.log("Got data from server: " + JSON.stringify(data));
        this.modelStore.load(data);
        if (data.flash != null) {
          this.setFlash(data.flash);
        }
        if (data.session != null) {
          _ref = data.session;
          for (key in _ref) {
            value = _ref[key];
            this.session[key] = value;
          }
        }
        this.errors = data.errors;
        if (data.redirect != null) {
          return Turbolinks.visit(data.redirect);
        } else {
          if (this.errors) {
            if (callback_message) {
              error_callback_message = ["" + callback_message + "_errors", "errors"];
            } else {
              error_callback_message = "errors";
            }
            end;
            return this.broadcast(error_callback_message, this.errors);
          } else {
            return this.broadcast([callback_message, "render"]);
          }
        }
      }
    };

    Runtime.prototype.go = function() {
      var contr, id, json, newActive, parsed, _ref;
      this._oldFlash = this._flash;
      this._flash = {};
      json = $("#" + this.dataId).html();
      parsed = null;
      if (json) {
        parsed = $.parseJSON(json);
      }
      this.processServerData(parsed);
      newActive = [];
      _ref = this.controllers;
      for (id in _ref) {
        contr = _ref[id];
        if (jQuery("#" + id).length > 0) {
          newActive.push(contr);
        }
      }
      if (this.active.length) {
        this.broadcast("stop");
        window.onbeforeunload = null;
        window.onfocus = null;
        window.onblur = null;
        if (this.onfocusId) {
          clearInterval(this.onfocusId);
        }
        this.onfocusId = null;
      }
      if (newActive.length) {
        this.active = newActive;
        this.broadcast("start");
        window.onfocus = (function(_this) {
          return function() {
            _this._startSafariKludge();
            console.log("onfocus detected, resuming");
            return _this.broadcast("resume");
          };
        })(this);
        window.onblur = (function(_this) {
          return function() {
            _this._stopSafariKludge();
            console.log("onblur detected, pausing");
            return _this.broadcast("pause");
          };
        })(this);
        return this._startSafariKludge();
      } else {
        return this.active = [];
      }
    };

    Runtime.prototype._startSafariKludge = function() {
      this._stopSafariKludge();
      this.lastFired = new Date().getTime();
      console.log("safari kludge setting last fired to " + this.lastFired);
      return this.onfocusId = setInterval((function(_this) {
        return function() {
          var now;
          now = new Date().getTime();
          if (now - _this.lastFired > 2000) {
            console.log("safari onfocus kludge fired, now = " + now + ", last = " + _this.lastFired);
            _this.broadcast("pause");
            _this.broadcast("resume");
          }
          return _this.lastFired = now;
        };
      })(this), 500);
    };

    Runtime.prototype._stopSafariKludge = function() {
      if (this.onfocusId != null) {
        clearInterval(this.onfocusId);
      }
      return this.onfocusId = null;
    };

    Runtime.prototype.run = function() {
      var self;
      self = this;
      $(function() {
        return self.go();
      });
      return $(document).on('pagebeforeshow', function() {
        return self.go();
      });
    };

    return Runtime;

  })();

  MVCoffee.Controller = (function() {
    function Controller(id, runtime) {
      this.id = id;
      this.runtime = runtime;
      this.errors = __bind(this.errors, this);
      this.selector = "#" + id;
      this.timerId = null;
      this.isActive = false;
      this.processServerData = this.runtime.processServerData;
      this.getFlash = this.runtime.getFlash;
      this.setFlash = this.runtime.setFlash;
      this.getSession = this.runtime.getSession;
      this.setSession = this.runtime.setSession;
      this.getErrors = this.runtime.getErrors;
      this.timerCount = 0;
    }

    Controller.prototype.start = function() {
      var token;
      this.isActive = true;
      token = jQuery("meta[name='csrf-token']");
      if (token != null ? token.length : void 0) {
        this.authenticity_token = token.attr("content");
      }
      this.onStart();
      this.render();
      if (this.refresh != null) {
        return this.startTimer();
      }
    };

    Controller.prototype.resume = function() {
      this.onResume();
      console.log("resume called on controller " + this.toString());
      console.log("isActive = " + this.isActive);
      if ((this.refresh != null) && !this.isActive) {
        this.isActive = true;
        this.refresh();
        return this.startTimer();
      }
    };

    Controller.prototype.pause = function() {
      this.onPause();
      console.log("pause called on controller " + this.toString());
      if (this.refresh != null) {
        this.isActive = false;
        return this.stopTimer();
      }
    };

    Controller.prototype.stop = function() {
      this.isActive = false;
      this.onStop();
      if (this.refresh != null) {
        return this.stopTimer();
      }
    };

    Controller.prototype.turbolinkForms = function(customizations) {
      var $searchInside, self;
      if (customizations == null) {
        customizations = {};
      }
      if (typeof Turbolinks !== "undefined" && Turbolinks !== null) {
        self = this;
        if (customizations.scope != null) {
          $searchInside = jQuery(customizations.scope);
        } else {
          $searchInside = jQuery("body");
        }
        $searchInside.find("form").each((function(_this) {
          return function(index, element) {
            var $element, customization;
            console.log("turbolinking " + element.id);
            if (customizations[element.id] != null) {
              customization = customizations[element.id];
              return $(element).submit(function() {
                var confirm, doPost, method, model;
                doPost = true;
                model = customization.model;
                if (model != null) {
                  model.populate();
                  method = "" + element.id + "_errors";
                  if (self[method] != null) {
                    self[method](model.errors);
                  } else {
                    console.log("!!! method " + method + " not implemented !!!");
                  }
                  doPost = model.isValid();
                }
                confirm = customization.confirm;
                if (doPost && (confirm != null)) {
                  if (confirm instanceof Function) {
                    doPost = confirm();
                  } else {
                    doPost = window.confirm(confirm);
                  }
                }
                if (doPost) {
                  self.turbolinksSubmit(element);
                }
                return false;
              });
            } else {
              $element = $(element);
              if (element.method === "get" || element.method === "GET") {
                return $(element).submit(function() {
                  Turbolinks.visit(element.action);
                  return false;
                });
              } else {
                return $(element).submit(function() {
                  self.turbolinksSubmit(element);
                  return false;
                });
              }
            }
          };
        })(this));
        console.log("Looking for post links");
        $searchInside.find("a[data-method='post']").each((function(_this) {
          return function(index, element) {
            console.log("Found a post link! url=" + element.href);
            console.log("element.id = " + element.id);
            if (element.id) {
              console.log("Passes existence test");
            } else {
              console.log("Fails existence test");
            }
            return jQuery(element).click(function() {
              var confirm, doPost;
              doPost = true;
              confirm = jQuery(element).data("confirm");
              if (confirm != null) {
                doPost = window.confirm(confirm);
              }
              if (doPost) {
                jQuery.ajax({
                  url: element.href,
                  type: 'POST',
                  success: function(data) {
                    return _this.runtime.processServerData(data, element.id);
                  },
                  dataType: "json"
                });
              }
              return false;
            });
          };
        })(this));
        return $searchInside.find("a[data-method='delete']").each((function(_this) {
          return function(index, element) {
            console.log("Found a delete link! url=" + element.href);
            return jQuery(element).click(function() {
              var confirm, doPost;
              doPost = true;
              confirm = jQuery(element).data("confirm");
              if (confirm != null) {
                doPost = window.confirm(confirm);
              }
              if (doPost) {
                jQuery.ajax({
                  url: element.href,
                  type: 'DELETE',
                  success: function(data) {
                    return _this.runtime.processServerData(data, element.id);
                  },
                  dataType: "json"
                });
              }
              return false;
            });
          };
        })(this));
      }
    };

    Controller.prototype.get = function(url, callback_message) {
      if (callback_message == null) {
        callback_message = "render";
      }
      return $.get(url, this.runtime.session, (function(_this) {
        return function(data) {
          return _this.runtime.processServerData(data, callback_message);
        };
      })(this), 'json');
    };

    Controller.prototype.post = function(url, params, callback_message) {
      if (params == null) {
        params = {};
      }
      if (callback_message == null) {
        callback_message = "render";
      }
      $.extend(params, {
        authenticity_token: this.authenticity_token
      }, this.session);
      return $.post(url, params, (function(_this) {
        return function(data) {
          return _this.runtime.processServerData(data, callback_message);
        };
      })(this), 'json');
    };

    Controller.prototype.turbolinksSubmit = function(submitee) {
      var element;
      element = submitee;
      if (submitee instanceof jQuery) {
        element = submitee.get(0);
      }
      console.log("Submiting " + element.id + " over turbolinks");
      jQuery.post(element.action, $(element).serialize(), (function(_this) {
        return function(data) {
          return _this.processServerData(data, element.id);
        };
      })(this), 'json');
      return false;
    };

    Controller.prototype.refreshInterval = 60000;

    Controller.prototype.refresh = null;

    Controller.prototype.onStart = function() {};

    Controller.prototype.onPause = function() {};

    Controller.prototype.onResume = function() {};

    Controller.prototype.onStop = function() {};

    Controller.prototype.render = function() {};

    Controller.prototype.errors = function(errors) {
      return console.log("!!!!! The errors method was called on controller " + (this.toString()) + " but not implemented!!!!!");
    };

    Controller.prototype.toString = function() {
      return this.id;
    };

    Controller.prototype.startTimer = function() {
      var self;
      if (this.timerId != null) {
        this.stopTimer();
      }
      if ((this.refreshInterval != null) && this.refreshInterval > 0) {
        self = this;
        this.timerCount += 1;
        console.log("Starting timer with count of " + this.timerCount);
        this.timerId = setInterval(function() {
          console.log("Firing timer with count of " + self.timerCount);
          return self.refresh.call(self);
        }, this.refreshInterval);
        return console.log("Started timerId " + this.timerId);
      }
    };

    Controller.prototype.stopTimer = function() {
      console.log("Stopping timer");
      if (this.timerId != null) {
        console.log("clearing the interval with timerId " + this.timerId);
        clearInterval(this.timerId);
      }
      return this.timerId = null;
    };

    return Controller;

  })();

  MVCoffee.ModelStore = (function() {
    ModelStore.prototype.MIN_DATA_FORMAT_VERSION = "1.0.0";

    function ModelStore(models) {
      if (models == null) {
        models = {};
      }
      this.modelDefs = {};
      this.store = {};
      this.register_models(models);
    }

    ModelStore.prototype.register_models = function(models) {
      var classdef, name, _results;
      if (models == null) {
        models = {};
      }
      _results = [];
      for (name in models) {
        classdef = models[name];
        _results.push(this._addModel(name, classdef));
      }
      return _results;
    };

    ModelStore.prototype._addModel = function(name, classdef) {
      var _base, _base1;
      this.modelDefs[name] = classdef;
      (_base = classdef.prototype).modelName || (_base.modelName = name);
      (_base1 = classdef.prototype).modelNamePlural || (_base1.modelNamePlural = MVCoffee.Pluralizer.pluralize(name));
      classdef.prototype.modelStore = this;
      return this.store[name] = {};
    };

    ModelStore.prototype.knowsAbout = function(name) {
      return this.store[name] != null;
    };

    ModelStore.prototype.load_model_data = function(modelName, data) {
      var model, modelObj, _i, _len, _results;
      if (Array.isArray(data)) {
        _results = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          modelObj = data[_i];
          model = new this.modelDefs[modelName](modelObj);
          _results.push(this.store[modelName][model.id] = model);
        }
        return _results;
      } else {
        model = new this.modelDefs[modelName](data);
        return this.store[modelName][model.id] = model;
      }
    };

    ModelStore.prototype.load = function(object) {
      var commands, foreignKeys, modelId, modelName, record, toBeRemoved, _i, _j, _len, _len1, _ref, _ref1, _results;
      if ((object.mvcoffee_version == null) || object.mvcoffee_version < this.MIN_DATA_FORMAT_VERSION) {
        throw "MVCoffee.DataStore requires minimum data format " + this.MIN_DATA_FORMAT_VERSION;
      }
      _ref = object.models;
      _results = [];
      for (modelName in _ref) {
        commands = _ref[modelName];
        if (this.modelDefs[modelName] != null) {
          if (commands.replace_on != null) {
            if (Array.isArray(commands.replace_on)) {
              toBeRemoved = [];
              _ref1 = commands.replace_on;
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                foreignKeys = _ref1[_i];
                toBeRemoved = toBeRemoved.concat(this.where(modelName, foreignKeys));
              }
            } else {
              toBeRemoved = this.where(modelName, commands.replace_on);
            }
            for (_j = 0, _len1 = toBeRemoved.length; _j < _len1; _j++) {
              record = toBeRemoved[_j];
              this._delete_with_cascade(modelName, record.id);
            }
          }
          if (commands.data != null) {
            this.load_model_data(modelName, commands.data);
          }
          if (commands["delete"] != null) {
            if (Array.isArray(commands["delete"])) {
              _results.push((function() {
                var _k, _len2, _ref2, _results1;
                _ref2 = commands["delete"];
                _results1 = [];
                for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
                  modelId = _ref2[_k];
                  _results1.push(this._delete_with_cascade(modelName, modelId));
                }
                return _results1;
              }).call(this));
            } else {
              _results.push(this._delete_with_cascade(modelName, commands["delete"]));
            }
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ModelStore.prototype.find = function(model, id) {
      var _ref;
      return (_ref = this.store[model]) != null ? _ref[id] : void 0;
    };

    ModelStore.prototype.findBy = function(model, conditions) {
      var id, match, prop, record, records, result, value, _ref;
      records = (_ref = this.store[model]) != null ? _ref : {};
      result = null;
      for (id in records) {
        record = records[id];
        match = true;
        for (prop in conditions) {
          value = conditions[prop];
          if (record[prop] !== value) {
            match = false;
          }
        }
        if (match) {
          result || (result = record);
        }
      }
      return result;
    };

    ModelStore.prototype.where = function(model, conditions) {
      var id, match, prop, record, records, result, value;
      records = this.store[model];
      result = [];
      for (id in records) {
        record = records[id];
        match = true;
        for (prop in conditions) {
          value = conditions[prop];
          if (record[prop] !== value) {
            match = false;
          }
        }
        if (match) {
          result.push(record);
        }
      }
      return result;
    };

    ModelStore.prototype.all = function(model) {
      var id, record, records, result;
      records = this.store[model];
      result = [];
      for (id in records) {
        record = records[id];
        result.push(record);
      }
      return result;
    };

    ModelStore.prototype["delete"] = function(model, id) {
      return delete this.store[model][id];
    };

    ModelStore.prototype._delete_with_cascade = function(model, id) {
      var record;
      record = this.store[model][id];
      if ((record["delete"] != null) && record["delete"] instanceof Function) {
        return record["delete"]();
      } else {
        return delete this.store[model][id];
      }
    };

    return ModelStore;

  })();

  MVCoffee.Model = (function() {
    function Model(obj) {
      this.addError = __bind(this.addError, this);
      if (obj != null) {
        this.populate(obj);
      }
    }

    Model.prototype.modelName = null;

    Model.prototype.fields = [];

    Model.prototype._associations_has_many = [];

    Model.prototype.errors = [];

    Model.prototype.valid = true;

    Model.order = function(array, order, opts) {
      var desc, ignoreCase, prop, result, value, _ref;
      if (opts == null) {
        opts = {};
      }
      result = array;
      _ref = order.split(/\s+/), prop = _ref[0], desc = _ref[1];
      value = 1;
      if ((desc != null) && desc === "desc") {
        value = -1;
      }
      ignoreCase = false;
      if (opts.ignoreCase) {
        ignoreCase = true;
      }
      result.sort(function(a, b) {
        a = a[prop];
        b = b[prop];
        if (ignoreCase) {
          if (a.toLowerCase) {
            a = a.toLowerCase();
          }
          if (b.toLowerCase) {
            b = b.toLowerCase();
          }
        }
        if (a > b) {
          return value;
        } else if (a < b) {
          return -value;
        } else {
          return 0;
        }
      });
      return result;
    };

    Model.all = function(options) {
      var result;
      if (options == null) {
        options = {};
      }
      result = this.prototype.modelStore.all(this.prototype.modelName);
      if (options.order) {
        result = this.sort(result, options.order);
      }
      return result;
    };

    Model.find = function(id) {
      return this.prototype.modelStore.find(this.prototype.modelName, id);
    };

    Model.prototype["delete"] = function() {
      var assoc, child, children, _i, _j, _len, _len1, _ref;
      _ref = this._associations_has_many;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        assoc = _ref[_i];
        children = this[assoc]();
        for (_j = 0, _len1 = children.length; _j < _len1; _j++) {
          child = children[_j];
          child["delete"]();
        }
      }
      return this.modelStore["delete"](this.modelName, this.id);
    };

    Model.prototype.destroy = function() {
      return this["delete"]();
    };

    Model.findFieldIndex = function(field) {
      var fields, i, index, _i, _ref;
      fields = this.prototype.fields;
      index = -1;
      for (i = _i = 0, _ref = fields.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        if (fields[i].name === field) {
          index = i;
        }
      }
      return index;
    };

    Model.validates = function(field, test) {
      var fields, index;
      if (!this.prototype.hasOwnProperty("fields")) {
        this.prototype.fields = [];
      }
      fields = this.prototype.fields;
      index = this.findFieldIndex(field);
      if (index < 0) {
        return fields.push({
          name: field,
          validates: [test]
        });
      } else {
        field = fields[index];
        if (field.validates != null) {
          if (Array.isArray(field.validates)) {
            return field.validates.push(test);
          } else {
            return field.validates = [field.validates, test];
          }
        } else {
          return field.validates = [test];
        }
      }
    };

    Model.types = function(field, type) {
      var fields, index;
      if (!this.prototype.hasOwnProperty("fields")) {
        this.prototype.fields = [];
      }
      fields = this.prototype.fields;
      index = this.findFieldIndex(field);
      if (index < 0) {
        return fields.push({
          name: field,
          type: type
        });
      } else {
        return fields[index].type = type;
      }
    };

    Model.displays = function(field, display) {
      var fields, index;
      if (!this.prototype.hasOwnProperty("fields")) {
        this.prototype.fields = [];
      }
      fields = this.prototype.fields;
      index = this.findFieldIndex(field);
      if (index < 0) {
        return fields.push({
          name: field,
          display: display
        });
      } else {
        return fields[index].display = display;
      }
    };

    Model.hasMany = function(name, options) {
      var methodName, self;
      if (options == null) {
        options = {};
      }
      methodName = options.as || MVCoffee.Pluralizer.pluralize(name);
      if (!this.prototype.hasOwnProperty("_associations_has_many")) {
        this.prototype._associations_has_many = [];
      }
      this.prototype._associations_has_many.push(methodName);
      self = this;
      return this.prototype[methodName] = function() {
        var constraints, foreignKey, modelStore, result;
        modelStore = self.prototype.modelStore;
        foreignKey = options.foreignKey || options.foreign_key || ("" + self.prototype.modelName + "_id");
        result = [];
        if (modelStore != null) {
          constraints = {};
          constraints[foreignKey] = this.id;
          result = modelStore.where(name, constraints);
        }
        if (options.order) {
          result = self.order(result, options.order);
        }
        return result;
      };
    };

    Model.has_many = Model.hasMany;

    Model.belongsTo = function(name, options) {
      var foreignKey, methodName, self;
      if (options == null) {
        options = {};
      }
      methodName = options.as || name;
      foreignKey = options.foreignKey || options.foreign_key || ("" + name + "_id");
      self = this;
      return this.prototype[methodName] = function() {
        var modelStore, result;
        modelStore = self.prototype.modelStore;
        result = null;
        if (modelStore != null) {
          result = modelStore.find(name, this[foreignKey]);
        }
        return result;
      };
    };

    Model.belongs_to = Model.belongsTo;

    Model.prototype.isValid = function() {
      return this.valid;
    };

    Model.prototype.populate = function(obj) {
      var field, selector, value, _i, _len, _ref;
      if (obj != null) {
        for (field in obj) {
          value = obj[field];
          if (obj.hasOwnProperty(field)) {
            if ((value instanceof Object || value instanceof Array) && this.modelStore.knowsAbout(field)) {
              this.modelStore.load_model_data(field, value);
            } else {
              this[field] = value;
            }
          }
        }
      } else {
        _ref = this.fields;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          if (this.modelName != null) {
            selector = "#" + this.modelName + "_" + field.name;
          } else {
            selector = "#" + field.name;
          }
          if ((field.type != null) && field.type === 'boolean') {
            this[field.name] = jQuery(selector).is(':checked');
          } else {
            this[field.name] = jQuery(selector).val();
          }
        }
      }
      return this.validate();
    };

    Model.prototype.validate = function() {
      var confirm, field, isNumber, matches, subval, tokenizer, validation, validations, value, _i, _j, _len, _len1, _ref;
      this.valid = true;
      this.errors = [];
      _ref = this.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        field = _ref[_i];
        if (field.validates != null) {
          validations = field.validates;
          if (!Array.isArray(validations)) {
            validations = [validations];
          }
          for (_j = 0, _len1 = validations.length; _j < _len1; _j++) {
            validation = validations[_j];
            if (validation.test === 'acceptance') {
              value = validation.accept;
              if (value == null) {
                value = '1';
              }
              this.__performValidation(field, validation, null, "must be accepted", function(val) {
                return val === value;
              });
            } else if (validation.test === 'confirmation') {
              confirm = this["" + field.name + "_confirmation"];
              this.__performValidation(field, validation, null, "doesn't match confirmation", function(val) {
                return (val != null) && val !== "" && (confirm != null) && val === confirm;
              });
            } else if (validation.test === 'email') {
              this.__performValidation(field, validation, null, "must be a valid email address", function(val) {
                return (val != null) && val.match(/^([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})$/);
              });
            } else if (validation.test === 'exclusion') {
              matches = validation["in"] || [];
              this.__performValidation(field, validation, null, "is reserved", function(val) {
                return (val != null) && !(__indexOf.call(matches, val) >= 0);
              });
            } else if (validation.test === 'format') {
              matches = validation["with"] || /.*/;
              this.__performValidation(field, validation, null, "is invalid", function(val) {
                return (val != null) && matches.test(val);
              });
            } else if (validation.test === 'inclusion') {
              matches = validation["in"] || [];
              this.__performValidation(field, validation, null, "is not included in the list", function(val) {
                return (val != null) && __indexOf.call(matches, val) >= 0;
              });
            } else if (validation.test === 'length') {
              tokenizer = function(val) {
                return val.split("");
              };
              if (validation.tokenizer != null) {
                tokenizer = validation.tokenizer;
              }
              if (validation.minimum != null) {
                if (typeof validation.minimum === "number") {
                  subval = null;
                  value = validation.minimum;
                } else {
                  subval = validation.minimum;
                  value = subval.value;
                }
                this.__performValidation(field, validation, subval, "is too short (minimum is " + value + " characters)", function(val) {
                  return (val != null) && tokenizer(val).length >= value;
                });
              }
              if (validation.maximum != null) {
                if (typeof validation.maximum === "number") {
                  subval = null;
                  value = validation.maximum;
                } else {
                  subval = validation.maximum;
                  value = subval.value;
                }
                this.__performValidation(field, validation, subval, "is too long (maximum is " + value + " characters)", function(val) {
                  return (val == null) || tokenizer(val).length <= value;
                });
              }
              if (validation["is"] != null) {
                if (typeof validation["is"] === "number") {
                  subval = null;
                  value = validation["is"];
                } else {
                  subval = validation["is"];
                  value = subval.value;
                }
                this.__performValidation(field, validation, subval, "is the wrong length (must be " + value + " characters)", function(val) {
                  return (val != null) && tokenizer(val).length === value;
                });
              }
            } else if (validation.test === 'numericality') {
              if ((validation.only_integer != null) && validation.only_integer) {
                isNumber = this.__performValidation(field, validation, null, "must be an integer", function(val) {
                  return /^[-+]?\d+$/.test(val);
                });
              } else {
                isNumber = this.__performValidation(field, validation, null, "must be a number", function(val) {
                  var number;
                  number = parseFloat(val);
                  return /^[-+]?\d*\.?\d*(e\d+)?$/.test(val) && number === number;
                });
              }
              if (isNumber) {
                if (validation.greater_than != null) {
                  if (typeof validation.greater_than === "number") {
                    value = validation.greater_than;
                    subval = null;
                  } else {
                    subval = validation.greater_than;
                    value = subval.value;
                  }
                  this.__performValidation(field, validation, subval, "must be greater than " + value, function(val) {
                    return parseFloat(val) > value;
                  });
                }
                if (validation.greater_than_or_equal_to != null) {
                  if (typeof validation.greater_than_or_equal_to === "number") {
                    subval = null;
                    value = validation.greater_than_or_equal_to;
                  } else {
                    subval = validation.greater_than_or_equal_to;
                    value = subval.value;
                  }
                  this.__performValidation(field, validation, subval, "must be greater than or equal to " + value, function(val) {
                    return parseFloat(val) >= value;
                  });
                }
                if (validation.equal_to != null) {
                  if (typeof validation.equal_to === "number") {
                    subval = null;
                    value = validation.equal_to;
                  } else {
                    subval = validation.equal_to;
                    value = subval.value;
                  }
                  this.__performValidation(field, validation, subval, "must be equal to " + value, function(val) {
                    return parseFloat(val) === value;
                  });
                }
                if (validation.less_than != null) {
                  if (typeof validation.less_than === "number") {
                    value = validation.less_than;
                    subval = null;
                  } else {
                    subval = validation.less_than;
                    value = subval.value;
                  }
                  this.__performValidation(field, validation, subval, "must be less than " + value, function(val) {
                    return parseFloat(val) < value;
                  });
                }
                if (validation.less_than_or_equal_to != null) {
                  if (typeof validation.less_than_or_equal_to === "number") {
                    subval = null;
                    value = validation.less_than_or_equal_to;
                  } else {
                    subval = validation.less_than_or_equal_to;
                    value = subval.value;
                  }
                  this.__performValidation(field, validation, subval, "must be less than or equal to " + value, function(val) {
                    return parseFloat(val) <= value;
                  });
                }
                if (validation.odd != null) {
                  if (typeof validation.odd === "boolean") {
                    subval = null;
                    value = validation.odd;
                  } else {
                    subval = validation.odd;
                    value = true;
                  }
                  if (value) {
                    this.__performValidation(field, validation, subval, "must be odd", function(val) {
                      return Math.abs(parseFloat(val)) % 2 === 1;
                    });
                  }
                }
                if (validation.even != null) {
                  if (typeof validation.even === "boolean") {
                    subval = null;
                    value = validation.even;
                  } else {
                    subval = validation.even;
                    value = true;
                  }
                  if (value) {
                    this.__performValidation(field, validation, subval, "must be even", function(val) {
                      return parseFloat(val) % 2 === 0;
                    });
                  }
                }
              }
            } else if (validation.test === 'presence') {
              this.__performValidation(field, validation, null, "can't be empty", function(val) {
                return (val != null) && /\S+/.test(val);
              });
            } else if (validation.test === 'absence') {
              this.__performValidation(field, validation, null, "must be blank", function(val) {
                return !((val != null) && /\S+/.test(val));
              });
            } else {
              if (typeof this[validation.test] !== 'function') {
                throw "custom validation is not a function";
              }
              this.__performValidation(field, validation, null, "is invalid", this[validation.test]);
            }
          }
        }
      }
      return this.valid;
    };

    Model.prototype.__performValidation = function(field, validation, subval, message, comparison) {
      var data;
      if ((validation.only_if != null) && !this[validation.only_if]()) {
        return true;
      }
      if ((validation.unless != null) && this[validation.unless]()) {
        return true;
      }
      if (subval != null) {
        if ((subval.only_if != null) && !this[subval.only_if]()) {
          return true;
        }
        if ((subval.unless != null) && this[subval.unless]()) {
          return true;
        }
      }
      data = this[field.name];
      if ((validation.allow_null != null) && validation.allow_null && (data == null)) {
        return true;
      }
      if ((validation.allow_blank != null) && validation.allow_blank && ((data == null) || !/\S+/.test(data))) {
        return true;
      }
      if (!comparison(data)) {
        this.addError(field, validation, subval, message);
        return false;
      }
      return true;
    };

    Model.prototype.addError = function(field, validation, subval, message) {
      var name;
      this.valid = false;
      name = field.display;
      if (name == null) {
        name = field.name;
        if (name.length > 0) {
          name = name[0].toUpperCase() + name.slice(1);
          name = name.split("_").join(" ");
        }
      }
      if ((subval != null ? subval.message : void 0) != null) {
        return this.errors.push("" + name + " " + subval.message);
      } else if ((validation != null ? validation.message : void 0) != null) {
        return this.errors.push("" + name + " " + validation.message);
      } else {
        return this.errors.push("" + name + " " + message);
      }
    };

    return Model;

  })();

}).call(this);
